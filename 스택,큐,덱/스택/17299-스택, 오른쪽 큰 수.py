# 오른쪽의 큰 수에서 제일 왼쪽이라고 했으므로
# for문으로 차례로 조회할 때마다 오른쪽으로 진행되므로
# 스택에 현재 인덱스를 저장해가면 다음 인덱스부터 오른쪽이 되면서
# 현재 큰 수가 맞으면 현재의 비교하는 인덱스를 이 값으로 갱신하고
# 스택에서 담겼던 이전 인덱스들도 비교해서 오른쪽의 큰 수인지 갱신해나간다.
# 여기서의 큰 수 기준은 숫자의 개수이므로 입력한 숫자들의 개수를 카운팅한 배열이 있어야한다.

N = int(input())
A = list(map(int, input().split()))

count = [0] * 1000001              # 여기서의 큰 수 기준은 숫자의 개수이므로
stack = []
answer = [-1] * N


for i in A:                        # 입력한 숫자들의 개수를 카운팅한 배열이 있어야한다.
    count[i] += 1


for i in range(N):                 # for문으로 차례로 조회할 때마다 오른쪽으로 진행되므로
    print(stack)
    while stack and count[A[stack[-1]]] < count[A[i]]:  # 현재 큰 수가 맞으면 현재의 비교하는 인덱스를 이 값으로 갱신하고
                                                        # 스택에서 담겼던 이전 인덱스들도 비교해서 오른쪽의 큰 수인지 갱신해나간다.
        idx = stack.pop()
        answer[idx] = A[i]

    stack.append(i)                # 스택에 현재 인덱스를 저장해가면 다음 인덱스부터 오른쪽이 되면서 루프가 진행된다.


print(' '.join(map(str, answer)))