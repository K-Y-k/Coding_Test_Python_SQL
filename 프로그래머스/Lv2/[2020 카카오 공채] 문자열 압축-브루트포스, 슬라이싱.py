# 문자의 길이가 1000자까지이므로 2중 for문을 돌려도 시간초과 발생을 하지 않는다.
# 그래서 1부터 주어진 문자길이까지 조회하며
# 각 길이 간격으로 기준 문자가 맞을 때까지 카운팅하고
# 현재 문자가 기준 문자랑 맞지 않은 경우 지금까지 카운팅한 숫자가 1이상이면 숫자를 앞에 같이 넣어준 후의 압축 문자를 적용하여
# 이렇게 적용한 압축 문자의 총 길이를 결과 리스트에 넣고
# 각 길이에 대한 합축된 문자 길이들이 들어간 결과 리스트의 최소 값이 정답이 된다. 

def solution(s):
    answer = 0
    result_li = []
    
    for i in range(1, len(s)+1):             # 1부터 주어진 문자길이까지 조회하며
        count = 1
        a = ''
        tmp = s[:i]
        
        for j in range(i, len(s), i):        # 각 길이 간격으로
            if tmp == s[j:i+j]:              # 기준 문자가 맞을 때까지 카운팅하고
                count += 1

            else:                            # 현재 문자가 기준 문자랑 맞지 않은 경우
                if count != 1:               # 카운팅한 숫자가 1이상이면
                    a += str(count) + tmp    # 숫자를 앞에 같이 넣어준 후의 압축 문자를 적용하고
                else:
                    a += tmp                 # 1은 생략하므로 문자만 넣어준다.
                
                tmp = s[j:j+i]               # 그리고 현재 맞지 않은 문자를 기준으로 초기화 해준다.
                count = 1
        
        if count != 1:                       # 마지막으로 간격이 띄어넘어지면서 스킵된 마지막 문자도 잊지말고 처리해야한다.
            a += str(count) + tmp
        else:
            a += tmp
        
        
        result_li.append(len(a))             # 이렇게 적용한 압축 문자의 총 길이를 결과 리스트에 넣고
        
        
    answer = min(result_li)                  # 각 길이에 대한 합축된 문자 길이들이 들어간 결과 리스트의 최소 값이 정답이 된다. 
    
    
    return answer