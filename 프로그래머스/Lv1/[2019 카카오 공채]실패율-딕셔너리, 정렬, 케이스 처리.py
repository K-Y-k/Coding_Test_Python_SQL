# 내가 푼 방식
# N개의 스테이지까지이므로 1~N까지의 각 스테이지에 따른 실패율을 구하고 정렬하면 된다.
# 1. 1~N의 각 스테이지를 먼저 반복의 조회 대상으로 하고 
# 2. 그 각 스테이지에 따른 스테이지에 진입한 회원을 조사하여
# 3. 현재 스테이지까지 접근은 했지만 클리어는 하지 못한 유저 수와 
#    클리어 상관없이 현재 스테이지 자체를 접근한 모든 유저 수를 각 구하고
# 4. 실패율을 구하고 해당 스테이지와 실패율을 쌍으로 저정한 딕셔너리에 넣어주었다.
# 5. 딕셔너리를 실패율 값을 기준으로 내림차순 해주고 그 순서로 정답에 넣어주었다.

# 주의점
# 실패를 한 케이스들이 있었는데, 
# 이 이유는 x값 / 0과 같은 경우는 0을 나누는 것은 정의할 수 없어 실패율 0으로 따로 처리를 해주어야 했는데
# 그 부분을 확인하지 못하여 발행하였다. 


def solution(N, stages):
    answer = []
    stage_dic = {}
    
    for i in range(1, N+1):                                         # 1. 1~N의 각 스테이지를 먼저 반복의 조회 대상으로 하고 
        stage_access_count = 0                                      # 현재 스테이지까지 접근은 했지만 클리어는 하지 못한 유저 수 초기화
        stage_total_count = 0                                       # 현재 스테이지 자체를 접근한 모든 유저 수

        for j in stages: 
            if j == i:                                              # 현재 스테이지까지 접근은 했지만 클리어는 하지 못한 경우 카운팅
                stage_access_count += 1
            
            if j >= i:                                              # 클리어 상관없이 현재 스테이지 자체를 접근한 경우 카운팅
                stage_total_count += 1
                
        if stage_total_count > 0:                                   # 현재 스테이지 자체를 접근한 모든 유저 수가 0 이상이면
            tmp = stage_access_count/stage_total_count              # 실패율을 구하고 
            stage_dic[i] = tmp                                      # 해당 스테이지와 실패율을 쌍으로 저정한 딕셔너리에 넣어주었다.

        else:                                                       # 현재 스테이지 자체를 접근한 모든 유저 수가 0이면
            stage_dic[i] = 0                                        # 0으로 나눌 수 없어 0으로 처리한다고 했으므로 실패율 0으로 지정해서 넣어줌
    
    a = sorted(stage_dic.items(), key=lambda x:x[1], reverse=True)  # 딕셔너리를 실패율 값을 기준으로 내림차순 해주고
    
    for i in a:                                                     # 정렬된 순서로 정답에 넣어주었다.
        answer.append(i[0])
    
    
    return answer