# 시점을 이전 작업을 완료한 시점과 현재 시점으로 나누고 진행한다.

# 각 [요청시점, 소요시간]을 조회하면서 요청시점이 시작 시점보다 크고 현재 시점보다 작거나 같으면 
# 힙에 [소요시간, 요청시점]으로 넣어준다. (소요시간이 짧은순으로 넣어야 짧게 나오기 때문)
# 그러면 힙은 소요시간 기준으로 최소힙이 형성되고

# 힙에 값이 존재하면 제일 앞의 [소요시간, 요청시점]을 꺼내와서
# 이전 작업을 완료한 시점과 현재 시점을 새로 갱신해주고
# 정답에 현재 작업 완료 시간까지 더해주고
# 작업이 한번 완료되었으므로 루프 도는 시점도 1증가 시켜준다.

# 힙에 값이 없으면
# 현재 시점을 증가 시켜주고 다시 반복

import heapq

def solution(jobs):
    answer = 0          # 요청 작업을 합산할 정답부분
    
    i = 0               # 루프를 돌 시점  초기화
    start = -1          # 이전 작업을 완료한 시점 초기화
    now = 0             # 현재 시점 초기화
    
    heap = []           # 힙 선언
    
    while i < len(jobs):                              # 루프 도는 횟수가 요청 프로세스 총 개수가 될 때까지 반복
        for j in jobs:                                # 각 [요청시점, 소요시간]을 조회하면서
            if start < j[0] <= now:                   # 요청시점이 시작 시점보다 크고 현재 시점보다 작거나 같으면 
                heapq.heappush(heap, [j[1], j[0]])    # 힙에 [소요시간, 요청시점]으로 넣어준다. (소요시간이 짧은순으로 넣어야 짧게 나오기 때문)
        
        if len(heap) > 0:                             # 힙에 값이 존재하면
            p = heapq.heappop(heap)                   # 제일 앞의 [소요시간, 요청시점]을 꺼내와서
            
            start = now                               # 이전 작업을 완료한 시점과
            now += p[0]                               # 현재 시점을 새로 갱신해주고
            
            answer += (now - p[1])                    # 정답에 현재 작업 완료 시간까지 더해주고
            
            i += 1                                    # 작업이 한번 완료되었으므로 루프 도는 시점도 1증가 시켜준다.
        else:                                         # 힙에 값이 없으면
            now += 1                                  # 현재 시점을 증가 시켜주고 다시 반복
            
    
    return answer // len(jobs)                        # 문제에서 주어진 수식적용 후 반환