# 크루스칼 알고리즘이란?
# 네트워크(가중치를 간선에 할당한 그래프)의 모든 정점을 최소 비용으로 연결하는 최적 해답을 구하는 것으로
# 최소 비용인 트리로 형성하는 것이고 단 사이클이 형성되지 않아야 한다.
# 탐욕적인 방법이지만 최적으로 검증된 알고리즘이다.

# 1. 최소 비용 기준으로 오름차순 정렬한 후
#    첫 노드 값이 들어있는 set으로 중복을 적용하지 않은 경로 리스트를 만든다.
# 2. 모든 노드를 거쳐야하므로 while문 조건을 노드 개수만큼이 될때까지 반복하게 하고
#    노드를 조회하여 두 노드가 모두 있을 경우는 최소 비용으로 적용된 것이므로 넘어가고
#    둘 중 하나의 노드만 있으면 아직 이 두 노드는 연결된 것이 아닌 것이므로
#    두 노드를 넣어주고 (set이므로 중복 노드는 결국 생략)
#    최소 비용을 정답에 연산해주고 다음 while문으로 진행하도록 현재 루프 종료

def solution(n, costs):
    answer = 0
    
    costs.sort(key=lambda x:x[2])                        # 1. 최소 비용 기준으로 오름차순 정렬한 후
    
    routes = set([costs[0][0]])                          #    첫 노드 값이 들어있는 set으로 중복을 적용하지 않은 경로 리스트를 만든다.
    

    while len(routes) != n:                              # 2. 모든 노드를 거쳐야하므로 while문 조건을 노드 개수만큼이 될때까지 반복하게 하고
        for i in costs:                                  #    노드를 조회하여 
            if i[0] in routes and i[1] in routes:        #    두 노드가 모두 있을 경우는 최소 비용으로 적용된 것이므로
                continue                                 #    넘어가고

            if i[0] in routes or i[1] in routes:         #    둘 중 하나의 노드만 있으면 아직 이 두 노드는 연결된 것이 아닌 것이므로
                # routes.update({i[0], i[1]}) : update는 여러 값을 한번에 넣는 것
                routes.add(i[0])                         #    두 노드를 넣어주고 (set이므로 중복 노드는 결국 생략)
                routes.add(i[1])
                
                answer += i[2]                           #    최소 비용을 정답에 연산해주고
                break                                    #    다음 while문으로 진행하도록 현재 루프 종료 
                                                         #    (왜냐하면 위 노드를 넣기 전일 때에서 두 노드가 없었어서 넘어가진 경우가 있을 수 있으므로 현재 루프를 종료하고 다시 처음부터 초회해야함)
    
    
    return answer