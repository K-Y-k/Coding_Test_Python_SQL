# A:1 ~ Z:26까지 변경되는데 숫자가 11~26은 단일 숫자와 겹칠 수 있다.
   앞의 위치의 숫자와 현재위치 숫자를 붙일 때 10~26에 없으면 단독의 숫자만 가능한 것이므로 d[i-1]
   앞의 위치의 숫자와 현재위치 숫자를 붙일 때 10~26에 있으면 경우의 수가 d[i-2] + d[i-1]이 나온다.


N = list(map(int,input()))
d = [0] * (len(N)+1)

if N[0] == 0 :                                  # 처음에 0이 올 수 없다.
    print(0)
else :
    N = [0] + N                                # dp의 index와 N의 index를 맞추기 위해 0을 추가해준다. 
 
    d[0] = 1
    d[1] = 1                                     # d[0], d[1]은 항상 1이다. (d[0]은 d[2]를 처리하기 위해 1로 지정)

    for i in range(2, len(N)):
        if N[i] > 0:                               # 단독의 케이스 (0이 단독으로 올 수 없으므로 >0 조건처리해야한다.)
            d[i] = d[i-1]
            
        temp =int(str(N[i-1]) + str(N[i]))    # 앞의 자리와 이어 붙인 2자리 숫자
        if temp >= 10 and temp <= 26 :  # 10~26인 2자리 숫자인 케이스
            d[i] += d[i-2]
            
    print(d[len(N)-1] % 1000000)
    