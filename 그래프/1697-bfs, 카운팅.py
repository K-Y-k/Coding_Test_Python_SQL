# 너비우선 탐색으로 현재 값에서 -1, +1, 2배인 연산한 값들을 적용하여
# 각 연산한 값들이 문제에서의 범위(0~1000000)를 벗어나지 않고 아직 방문하지 않았으면 
# 현재 연산한 값의 방문한 시간은 연산 이전의 값의 방문 시간에 +1초로 적용해주고
# 현재 연산한 값을 큐에 넣어준다.
# 그렇게 큐에서 빼온 값이 문제에서 원하는 값이 될 경우
# 해당 값의 방문한 시간을 출력하고 반복을 종료한다. 

from collections import deque

def bfs(N):
    q = deque()
    q.append(N)                                     # 문제에서 시작하는 초깃값을 넣어주고

    while q:
        x = q.popleft()

        if x == K:                                  # 큐에서 빼온 값이 문제에서 원하는 값이 될 경우
            print(distance[x])                      # 해당 값의 방문한 시간을 출력하고 반복을 종료한다. 
            break

        for i in (x-1, x+1, x*2):                   # 현재 값에서 -1, +1, 2배인 연산한 값들을 적용하여
            if 0<=i<MAX and not distance[i]:        # 각 연산한 값들이 문제에서의 범위(0~1000000)를 벗어나지 않고 아직 방문하지 않았으면 
                distance[i] = distance[x] + 1       # 현재 연산한 값의 방문한 시간은 연산 이전의 값의 방문 시간에 +1초로 적용해주고
                q.append(i)                         # 현재 연산한 값을 큐에 넣어준다.

N, K = map(int, input().split())

MAX = 1000000
distance = [0] * (MAX + 1)

bfs(N)

