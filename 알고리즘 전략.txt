● 입출력, 문자열 처리
• 관련 함수들을 생각해서 활용하기


● 스택, 큐, 덱
• 리스트에 넣고 빼고를 활용해야하는 문제


● 수학
• 진법은 진법관련함수 생각해서 적용하자
• 최대공약수 구하는 함수(gcd함수 또는 유클리드 호제)를 생각해서 적용하자


● 그리디 알고리즘
1. 구하는 연산 공식을 정확히 집어야한다.
2. 각 케이스에 맞는 조건식으로 정확히 집어야한다.


● DP : 작은 문제에서 부터 큰 문제로 풀어가는 방식 
• DP라고 생각하기 기준
1.연속관련 내용의 문제 
2.각 경우의 수의 최대/최소 값의 문제
3.경우의 수의 규칙을 구하는 문제

• 풀이 방식
1. dp 배열 초기화(2차원 배열도 고려)
2. 일정 패턴이 오기 전까지 초반 부분의 답을 초기화해두기 
3. 작은 것으로 나누는 기준을 명확히 집어서 일정 규칙에 맞게 점화식을 세워 적용


● 그래프
• 어떤 상황이 주어지면 
  1.그래프로 모델링한 후 2.알고리즘을 적용해서 푼다.
  즉, 그래프로 만드는 것이 제일 중요하다.

- 그래프 용어
• 그래프: 정점과 간선(정점과 정점의 연결)으로 이루어진다.

• 경로   : 정점A에서 정점B로 가는 경로

• 사이클: 정점의 시작점과 도착점이 같은 경로
            (즉, 다시 돌아오는 경로)

• 단순경로/단순 사이클: 같은 정점을 2번이상 방문하지 않는 경로/사이클
                              (즉, 일반적인 경로/사이클이 이 뜻임)

• 그래프는 방향이 있는 그래프와 없는 그래프(=양방향)가 있다. 
   방향 없는 그래프는 모두 방향이 있게 만들어야한다.

• 정점A->정점B의 간선이 여러 개일 수 있다. 
  이 때는 그때 문제 상황에 따라 처리해주어야한다.

• 루프: 간선의 양 끝점(정점)이 같은 경우 ex) A->A

• 가중치: 간선에 써있는 값 
            즉 이는 이동거리/시간/비용 등을 표현한다. 
            간선에 가중치 표기가 없으면 기본값은 1

• 차수 : 해당 정점과 연결되어 있는 간선의 개수
          In-degree: 해당 정점으로 들어오는 방향의 간선 개수
          Out-degree: 해당 정점이 아닌 상대 정점으로 들어가는 방향의 간선 개수

- 그래프로 표현하기
  주로 사용하는 방식 = 인접 리스트로 저장방식
• 리스트를 이용해서 구현한다.
• A[i] = i와 연결된 정점을 리스트로 포함하고 있음

(2,3번 방식이 연결된 간선을 효율적으로 찾을 수 있다.
 하지만 2번 인접 행렬의 공간복잡도는 O(V^2)이고 3번 리스트 방식은 O(E)이므로 2번은 사용 안함)


- 그래프 탐색
• 목적: 임의의 정점에서 시작해서 연결되어 있는 모든 정점을 1번씩 방문하는 것

1.DFS
  • 하나의 정점에서 한 정점까지 끝까지 방문한 후 다시 돌아와서 다른 정점으로 가는 깊이우선 탐색
  • 스택으로 구현, check[i]을 활용해서 방문하면 0에서 1로 변경, 재귀호출로 구현가능
  • 인접리스트로 구현한 DFS의 시간 복잡도 = O(V+E) = O(E)
  • 이를 활용하는 예시) 사이클을 찾는 문제
2.BFS
  • 같은 너비이면 한번에 가는 너비우선 탐색 
  • 큐로 구현
  • 최단거리를 구할 때는 DFS는 안되고 이 방식을 사용해야한다.
  • 이를 활용하는 예시) 주변 이동하면서 구하는 문제


- 그래프 연결요소 개수
• ex1) 연결된 그래프가 나뉘어져 있으면 연결요소 2개
• ex2) 연결된 그래프가 하나만 있으면 연결요소 1개
• 즉, DFS/BFS의 시작지점의 개수로 연결요소의 개수를 구할 수 있다.
  (시작 지점을 새로 한다는 것은 다른 연결요소가 있다는 뜻이므로)


- 이분 그래프
• 하나의 그래프를 2개로 나눌 수 있는 그래프
• 이분 그래프의 구현은 DFS/BFS 모두 구현가능



● 트리
- 트리의 정의
• 트리는 그래프이지만, 사이클이 없는 연결 그래프이기에 
  특징이 정점의 개수는 V개 간선의 개수는 V-1개이다.
  하지만 무조건 V개, V-1개라고 트리는 아니다. (왜냐하면 분리되어 있는 경우도 있기에 즉, 트리일 때의 성질) 
  즉, 모두 연결되어있다라는 조건이 추가되어야 한다.
  => 트리의 조건: 1.정점의 개수=V/간선의 개수=V-1 2
                       2.모두 연결된 그래프 


- 트리의 루트
• 트리는 루트가 정의되어 있지 않지만 내가 임의로 정의할 수 있다.
  트리의 제일 중요한 점으로 트리는 루트가 있을 수 있고 없을 수 있다!
  • 부모, 자식 관계
    루트가 있는 트리는 루트부터 아래로 방향을 정할 수 있고 이는 부모-자식 관계가 생긴다.
     • 부모가 없는 노드 = 루트 
     • 자식이 없는 노드(마지막 깊이의 노드들) = 단말 정점
  • 조상, 자손 관계
    • 조상은 자기 자신, 부모, 부모의 부모를 포함한다.
    • 자손은 자기 자신, 자식, 자식의 자식


- 트리의 종류
1. 이진 트리
• 트리중 가장 유명한 트리
• 자식을 최대 2개만 가지는 트리

2. 포화 이진 트리
• 단말 정점의 높이가 모두 같고 꽉 차있는 트리
• 즉, 높이 h인 트리 노드 개수 = 2^h - 1

3. 완전 이진 트리
• 포화 이진 트리에서 마지막 깊이에서 오른쪽 단말 노드에 일부가 없는 것
  즉, 왼쪽 단말 노드에 일부가 없는데 오른쪽 단말 노드에 일부가 있으면 완전 이진 트리가 아니다.
• 하지만 포화 이진 트리처럼 꽉 차 있는 것도 완전 이진 트리에 포함된다.


- 트리의 표현
• 트리는 그래프이므로 그래프에 저장하던 방식을 그대로 사용한다.
• 루트가 있는 트리일 경우 = 트리의 부모만 저장하는 방식(=UnionFind방식) 
  : 모든 노드는 부모를 하나만 가지고 있고 부모가 없는 노드는 루트 하나만 있으므로 이 방식이 가능한 것
    -> 이 방식은 부모 찾는 시간은 빠르지만 자식 찾는 시간은 O(N)으로 느리다.

• 완전 이진 트리인 경우 = 배열로 표현(=Heap, Segment Tree방식)
  ex) 부모 노드가 x인 경우, 자식 노드는 2x, 2x+1로 나타낸다.

• 이진트리인 경우 = 구현체, 클래스를 정의해서 표현 가능


- 트리 순회(탐색)
• 트리는 그래프이므로 DFS/BFS 모두 가능
• DFS는 3가지 출력 순서가 있다. 노드 방문을 언제할지의 차이
  1.프리오더(루-왼-오)   : 자식의 값을 구할 때 부모의 값을 이용해야한다면 이 방식을 사용
  2.인오더(왼-루-오)      : BST에서 삭제를 구현할 때 사용(즉, 쓸 일 별로 없다), 이진트리는 이 방식 사용 못함
  3.포스트오더(왼-오-루) : 거의 가장 많이 쓰고 중요함(자식의 정보를 이용해서 현재 노드의 값을 계산할 때 사용하므로)
                                현재 노드의 값을 구할 때 자식의 값을 이용해야한다면 이 방식을 사용


- 트리 탐색
• 트리는 그래프이므로 DFS/BFS 모두 가능
• 트리는 사이클이 없으므로 임의 두 정점 사이의 경로는 1개이다.
• 즉, 최단 거리를 구하는 문제이면 DFS/BFS로 구할 수 있다. 
  경로가 1개라서 찾은 그 경로가 최단 거리


- 트리의 지름
• 트리에 존재하는 모든 경로 중 가장 긴 것이다.
• 트리의 지름은 탐색 2번으로 구할 수 있다.
  1. 한 정점 s에서 모든 정점까지의 거리를 구한다.(=DFS/BFS로 구함) 이때 가장 먼 거리인 정점을 u라고 하고
  2. u에서 모든 정점까지의 거리를 구한다. 이때 가장 먼 거리인 정점을 v를 구한다.
  3. u와 v사이의 거리가 트리의 지름이다.
• 포스트 오더를 이용해서도 구할 수 있다.

