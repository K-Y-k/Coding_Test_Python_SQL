# M과 N의 범위가 40000까지라서 경우의 수가 40000 * 40000 = 16억가지의 경우가 나오기 때문에
# 일반적인 하나씩 증가하며 반복문처리할 수 가 없다. (보통 1억이 1초로 16초가 예상된다.)

# 여기 문제에서 <x,y>가 몇번째 해인지 물어보는 것이기에 
# 만약 구하고 싶은 M,N은 5,7이고 x,y가 3, 2이면 x를 고정시키고 M의 단위인 5씩 +를 해주면 
# y에서의 값만 비교해서 찾아주면 되므로 O(N)의 시간복잡도로 가능해진다.

# 즉, M의 단위인 5씩 뛰어넘으면서 x가 3인 것만 나오는 것중 y의 값이 2인 것을 찾으면 된다.

# 주의점은 y를 구할 때 조건이 N의 단위로 나눈 나머지로 확인하는 것이므로
# 만약 y의 값이 N으로 나누어떨어지면 0이 나오므로 
# 이를 방지하기 위해 처음에 기존 x와 y값에 -1을 해주어 나누어 떨어지지 않게 만들고 
# 만약 y의 값이 같은 것이 나왔으면 x에 다시 +1을 해주면서 출력한다.

T = int(input())                                # 테스트 케이스 입력
for _ in range(T):                              # 테스트 케이스 만큼 반복
    M, N, x, y = map(int,input().split())       # 각 입력
    x -= 1                                      # x,y의 값이 M,N단위로 나누어 떨어지지 않게 -1를 적용하고 시작 
    y -= 1
    
    while x < M*N:                              # x를 기준으로 모두 조회
        if x % N == y:                          # N의 단위로 나누어 y값이 나오면
            print(x+1)                          # 처음에 -1을 해줬으므로 다시 원래 값으로 나오게 +1을 해주면서 출력
            break
        x += M                                  # M의 단위로 +해준다.
    else:                                       # 모두 조회해도 없으면
        print(-1)                               # -1을 출력한다.