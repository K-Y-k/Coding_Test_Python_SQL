# N의 범위가 1~15까지이므로 선택의 방법에 따른 재귀 방식을 이용해서 하면
# 1.선택한다 2.선택하지 않는다. 로 최대 2^15 = 32768가지로 얼마 되지않아 해당 방식이 사용 가능하다.

# 케이스는
# 1) N+1일까지 왔을 때  : 이번 경우의 수에서의 최대 비용과 현재까지의 최대 비용을 비교해서 최대 값을 저장
# 2) N+1일보다 넘었으면 : 해당되는 경우의 수가 아니므로 아무 일도 일어나지 않게 그냥 반환 처리
# 3) 다음 경우의 수도 봐야하는 경우
#    : 3-1) 상담을 하지 않은 경우: 날짜 인덱스는 현재인덱스+1, 금액은 현재까지의 금액 그대로
#      3-2) 상담을 한 경우       : 날짜 인덱스는 현재 인덱스+현재 인덱스에서의 상담 걸리는 기간, 금액은 현재까지의 금액 + 현재 인덱스에서 상담한 비용


import sys

def goAdvice(index, price_sum):                       # 함수 선언
    global max_result                                 # 최종 결과 전역 변수를 가져옴
    
    if index == N+1:                                  # 1) N+1일까지 왔으면   
        max_result = max(max_result, price_sum)       # 지금까지의 최종 결과 값과 현재 케이스에의 총 합과 비교하여 가장 큰 값을 최종 결과 변수에 저장
        return
    
    if index > N+1:                                   # 2) N+1일 보다 초과했으면 해당되는 케이스가 아니므로 그냥 반환
        return
    
    goAdvice(index+1, price_sum)                      # 3-1) 상담을 하지 않은 경우: 날짜 인덱스는 현재인덱스+1, 금액은 현재까지의 금액 그대로
    goAdvice(index+T[index], price_sum+P[index])      # 3-2) 상담을 한 경우 : 날짜 인덱스는 현재 인덱스+현재 인덱스에서의 상담 걸리는 기간, 금액은 현재까지의 금액 + 현재 인덱스에서 상담한 비용


N = int(input())                                      # 날짜 입력
max_result = 0                                        # 최종 결과 변수

T = [0] * (N+1)                                       # 상담 걸리는 기간 리스트 선언 및 초기화
P = [0] * (N+1)                                       # 상담 비용 리스트 선언 및 초기화

for i in range(1, N+1):                               # 문제에서 1~N일로 주어진 것을 그대로 맞추기위해 인덱스를 1부터 설정함
    T[i], P[i] = map(int, sys.stdin.readline().rstrip().split())

goAdvice(1, 0)                                        # 인덱스가 1부터 시작이므로
print(max_result)                                     # 위 재귀가 반복된 후 최종 결과 출력