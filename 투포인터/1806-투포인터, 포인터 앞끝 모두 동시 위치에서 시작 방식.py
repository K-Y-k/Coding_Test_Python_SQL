# 포인터 방식은 크게 두가지 방식이 있는데,
# 1) 앞에서 시작하는 포인터와 끝에서 시작하는 포인터가 만나는 방식
# 2) 두 포인터 모두 앞에서 시작하되 속도가 다르게 움직이는 방식이다.

# 내가 시도한 방식 1번 방식 = 시간초과
# 크기순으로 정렬한후 앞 끝 초깃값을 각각 맨앞 맨뒤로 인덱스를 정했으므로
# 문제에서 원하는 값보다 크거나 같으면이므로
# 앞 포인터에서 한칸씩 전진하며 앞~끝의 부분합으로 해당되는 값의 길이를 최소화 해갔지만
# sum()함수가 해당 배열의 모든 값을 조회하며 더해가므로
# 문제에서 100000개까지의 자연수가 있을 수 있어 배열 길이가 길면 결국 시간초과가 난 것 같다.

N, S = map(int, input().split())

num_li = list(map(int, input().split()))
num_li.sort()

left = 0
right = N-1
min_len = 0


while left < right:
    if sum(num_li[left:right+1]) >= S:
        if min_len == 0 or min_len > right-left+1:
            min_len = right-left+1

    left += 1


print(min_len)
        


# 여기서는 2번 방식으로 투포인터 알고리즘이 진행한다.

# 앞, 끝 시작값과 부분합과 최소 개수를 초기화 한후

# 부분합이 문제에서의 기준값보다 크거나 같으면 해당되는 경우이므로
#   최소 개수가 0이거나 최소 개수가 부분합의 길이보다 크면
#   최소 개수를 현재 부분합의 길이로 최신화해주고
#   다음 앞의 값을 포함한 부분합도 해당되는지 확인하기 위해 앞의 포인터를 한칸 전진하면서 전진 전의 값도 빼준다. 

# 부분합이 문제에서의 기준값보다 작으면 해당이 안되는 경우이므로
#   끝의 포인터를 한칸 전진하여 새로운 값을 더해주어 크기를 늘린다.

# 끝의 포인터가 리스트의 끝부분에 도달한 경우
#   더이상의 비교를 못하므로 반복 종료후 최소 길이 출력

N, S = map(int, input().split())
num_li = list(map(int, input().split()))

left = 0                                          # 앞, 끝 시작값과
right = 0

total = 0                                         # 부분합과
min_len = 0                                       # 최소 길이를 초기화 한후


while True:
    if total >= S:                                # 부분합이 문제에서의 기준값보다 크거나 같으면 해당되는 경우이므로
        if min_len == 0 or min_len > right-left:  # 최소 개수가 0이거나 최소 개수가 부분합의 길이보다 크면
            min_len = right-left                  # 최소 개수를 현재 부분합의 길이로 최신화해주고

        total -= num_li[left]                     # 다음 앞의 값을 포함한 부분합도 해당되는지 확인하기 위해 앞의 포인터를 한칸 전진할 것이므로 전진 전의 값도 빼준다. 
        left += 1                                 # 앞의 포인터 한칸 전진

    elif right == N:                              # 끝의 포인터가 리스트의 끝부분에 도달한 경우
        break                                     # 더이상의 비교를 못하므로 반복 종료

    else:                                         # 부분합이 문제에서의 기준값보다 작으면 해당이 안되는 경우이므로
        total += num_li[right]                    # 끝의 포인터를 한칸 전진하므로 새로운 값을 더해주어 크기를 늘린다.
        right += 1                                # 끝의 포인터를 한칸 전진


print(min_len)                                    # 최소 길이 출력
        